<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <title>تماس صوتی دوطرفه بدون اکو (WebRTC)</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
</head>
<body>
<h2>📞 تماس صوتی دوطرفه بدون اکو</h2>

<input id="myId" placeholder="شناسه من">
<input id="targetId" placeholder="شناسه مخاطب">
<br>
<button onclick="connect()">اتصال</button>
<button onclick="startCall()">شروع تماس</button>
<button id="answerBtn" onclick="answerCall()" disabled>پاسخ</button>

<h3>🎧 صدای طرف مقابل:</h3>
<audio id="remoteAudio" autoplay></audio>

<script>
    let stompClient, myId, targetId;
    let localStream, peerConnection, incomingOffer;
    let pendingCandidates = [];

    const rtcConfig = {
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    function connect() {
        myId = document.getElementById("myId").value.trim();
        if (!myId) return alert("شناسه خودت رو وارد کن!");

        const socket = new SockJS("/call-websocket-browser");
        stompClient = Stomp.over(socket);
        stompClient.debug = null;

        stompClient.connect({}, () => {
            console.log("✅ WebSocket وصل شد");
            stompClient.subscribe(`/topic/call/${myId}`, msg => {
                const signal = JSON.parse(msg.body);
                handleSignal(signal);
            });
        });
    }

    async function getMicStream() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });
            // 🔇 صدای خودت رو پخش نمی‌کنیم
            return stream;
        } catch (e) {
            alert("⚠️ خطا در دسترسی به میکروفون: " + e.message);
            throw e;
        }
    }

    async function startCall() {
        targetId = document.getElementById("targetId").value.trim();
        if (!targetId) return alert("شناسه مخاطب رو وارد کن!");

        localStream = await getMicStream();
        peerConnection = createPeerConnection(targetId);

        localStream.getTracks().forEach(track =>
            peerConnection.addTrack(track, localStream)
        );

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        sendSignal(targetId, "offer", offer);

        console.log("📤 Offer ارسال شد برای", targetId);
    }

    function createPeerConnection(remoteId) {
        const pc = new RTCPeerConnection(rtcConfig);

        pc.ontrack = event => {
            console.log("🎧 صدای طرف مقابل دریافت شد");
            document.getElementById("remoteAudio").srcObject = event.streams[0];
        };

        pc.onicecandidate = event => {
            if (event.candidate)
                sendSignal(remoteId, "ice_candidate", event.candidate);
        };

        pc.onconnectionstatechange = () => {
            console.log("🔄 وضعیت اتصال:", pc.connectionState);
        };

        return pc;
    }

    async function answerCall() {
        if (!incomingOffer) return;
        document.getElementById("answerBtn").disabled = true;

        console.log("📞 پاسخ به تماس از", incomingOffer.fromId);
        localStream = await getMicStream();
        peerConnection = createPeerConnection(incomingOffer.fromId);

        localStream.getTracks().forEach(track =>
            peerConnection.addTrack(track, localStream)
        );

        await peerConnection.setRemoteDescription(
            new RTCSessionDescription(incomingOffer.data)
        );

        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        sendSignal(incomingOffer.fromId, "answer", answer);

        // ✅ اضافه کردن candidateهای منتظر بعد از ست شدن RemoteDescription
        for (const candidate of pendingCandidates) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        }
        pendingCandidates = [];

        console.log("📤 Answer ارسال شد برای", incomingOffer.fromId);
    }

    async function handleSignal(signal) {
        switch (signal.type) {
            case "offer":
                console.log("📞 تماس از", signal.fromId);
                incomingOffer = signal;
                document.getElementById("answerBtn").disabled = false;
                break;

            case "answer":
                if (peerConnection) {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(signal.data)
                    );

                    for (const candidate of pendingCandidates) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                    pendingCandidates = [];
                }
                console.log("✅ تماس برقرار شد (Answer دریافت شد)");
                break;

            case "ice_candidate":
                if (peerConnection && peerConnection.remoteDescription) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(signal.data));
                } else {
                    pendingCandidates.push(signal.data);
                }
                break;
        }
    }

    function sendSignal(toId, type, data) {
        stompClient.send(
            "/app/call",
            {},
            JSON.stringify({ fromId: myId, toId, type, data })
        );
    }
</script>
</body>
</html>
