<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <title>ØªÙ…Ø§Ø³ ØµÙˆØªÛŒ Ø¯ÙˆØ·Ø±ÙÙ‡ Ø¨Ø¯ÙˆÙ† Ø§Ú©Ùˆ (WebRTC)</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
</head>
<body>
<h2>ğŸ“ ØªÙ…Ø§Ø³ ØµÙˆØªÛŒ Ø¯ÙˆØ·Ø±ÙÙ‡ Ø¨Ø¯ÙˆÙ† Ø§Ú©Ùˆ</h2>

<input id="myId" placeholder="Ø´Ù†Ø§Ø³Ù‡ Ù…Ù†">
<input id="targetId" placeholder="Ø´Ù†Ø§Ø³Ù‡ Ù…Ø®Ø§Ø·Ø¨">
<br>
<button onclick="connect()">Ø§ØªØµØ§Ù„</button>
<button onclick="startCall()">Ø´Ø±ÙˆØ¹ ØªÙ…Ø§Ø³</button>
<button id="answerBtn" onclick="answerCall()" disabled>Ù¾Ø§Ø³Ø®</button>

<h3>ğŸ§ ØµØ¯Ø§ÛŒ Ø·Ø±Ù Ù…Ù‚Ø§Ø¨Ù„:</h3>
<audio id="remoteAudio" autoplay></audio>

<script>
    let stompClient, myId, targetId;
    let localStream, peerConnection, incomingOffer;
    let pendingCandidates = [];

    const rtcConfig = {
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    function connect() {
        myId = document.getElementById("myId").value.trim();
        if (!myId) return alert("Ø´Ù†Ø§Ø³Ù‡ Ø®ÙˆØ¯Øª Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†!");

        const socket = new SockJS("/call-websocket-browser");
        stompClient = Stomp.over(socket);
        stompClient.debug = null;

        stompClient.connect({}, () => {
            console.log("âœ… WebSocket ÙˆØµÙ„ Ø´Ø¯");
            stompClient.subscribe(`/topic/call/${myId}`, msg => {
                const signal = JSON.parse(msg.body);
                handleSignal(signal);
            });
        });
    }

    async function getMicStream() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });
            // ğŸ”‡ ØµØ¯Ø§ÛŒ Ø®ÙˆØ¯Øª Ø±Ùˆ Ù¾Ø®Ø´ Ù†Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
            return stream;
        } catch (e) {
            alert("âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ†: " + e.message);
            throw e;
        }
    }

    async function startCall() {
        targetId = document.getElementById("targetId").value.trim();
        if (!targetId) return alert("Ø´Ù†Ø§Ø³Ù‡ Ù…Ø®Ø§Ø·Ø¨ Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†!");

        localStream = await getMicStream();
        peerConnection = createPeerConnection(targetId);

        localStream.getTracks().forEach(track =>
            peerConnection.addTrack(track, localStream)
        );

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        sendSignal(targetId, "offer", offer);

        console.log("ğŸ“¤ Offer Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ Ø¨Ø±Ø§ÛŒ", targetId);
    }

    function createPeerConnection(remoteId) {
        const pc = new RTCPeerConnection(rtcConfig);

        pc.ontrack = event => {
            console.log("ğŸ§ ØµØ¯Ø§ÛŒ Ø·Ø±Ù Ù…Ù‚Ø§Ø¨Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯");
            document.getElementById("remoteAudio").srcObject = event.streams[0];
        };

        pc.onicecandidate = event => {
            if (event.candidate)
                sendSignal(remoteId, "ice_candidate", event.candidate);
        };

        pc.onconnectionstatechange = () => {
            console.log("ğŸ”„ ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„:", pc.connectionState);
        };

        return pc;
    }

    async function answerCall() {
        if (!incomingOffer) return;
        document.getElementById("answerBtn").disabled = true;

        console.log("ğŸ“ Ù¾Ø§Ø³Ø® Ø¨Ù‡ ØªÙ…Ø§Ø³ Ø§Ø²", incomingOffer.fromId);
        localStream = await getMicStream();
        peerConnection = createPeerConnection(incomingOffer.fromId);

        localStream.getTracks().forEach(track =>
            peerConnection.addTrack(track, localStream)
        );

        await peerConnection.setRemoteDescription(
            new RTCSessionDescription(incomingOffer.data)
        );

        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        sendSignal(incomingOffer.fromId, "answer", answer);

        // âœ… Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† candidateÙ‡Ø§ÛŒ Ù…Ù†ØªØ¸Ø± Ø¨Ø¹Ø¯ Ø§Ø² Ø³Øª Ø´Ø¯Ù† RemoteDescription
        for (const candidate of pendingCandidates) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        }
        pendingCandidates = [];

        console.log("ğŸ“¤ Answer Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ Ø¨Ø±Ø§ÛŒ", incomingOffer.fromId);
    }

    async function handleSignal(signal) {
        switch (signal.type) {
            case "offer":
                console.log("ğŸ“ ØªÙ…Ø§Ø³ Ø§Ø²", signal.fromId);
                incomingOffer = signal;
                document.getElementById("answerBtn").disabled = false;
                break;

            case "answer":
                if (peerConnection) {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(signal.data)
                    );

                    for (const candidate of pendingCandidates) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                    pendingCandidates = [];
                }
                console.log("âœ… ØªÙ…Ø§Ø³ Ø¨Ø±Ù‚Ø±Ø§Ø± Ø´Ø¯ (Answer Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯)");
                break;

            case "ice_candidate":
                if (peerConnection && peerConnection.remoteDescription) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(signal.data));
                } else {
                    pendingCandidates.push(signal.data);
                }
                break;
        }
    }

    function sendSignal(toId, type, data) {
        stompClient.send(
            "/app/call",
            {},
            JSON.stringify({ fromId: myId, toId, type, data })
        );
    }
</script>
</body>
</html>
